---
title: "Семинар №1"
author: "Георгий Мороз, Ольга Ляшевская, Илья Щуров, НИУ ВШЭ"
date: "11 ноября 2015"
output: 
  knitrBootstrap::bootstrap_document:
    theme.chooser: TRUE
    highlight.chooser: TRUE
    highlight: Xcode
  toc: true
  toc_depth: 4
---
```{r, echo=FALSE}
loc <- Sys.setlocale('LC_ALL', 'C.UTF-8');
```

# Семинар №1: базовые возможности R

*Георгий Мороз, Ольга Ляшевская, Илья Щуров, НИУ ВШЭ*

Курс «Анализ лингвистических данных: квантитативные методы и визуализация».

Школа лингвистики НИУ ВШЭ, магистерская программа «Теория языка и компьютерная лингвистика», 2015-16 учебный год.

[Школа лингвистики](http://ling.hse.ru/) | [Все материалы курса](http://hsequantling.wikispaces.com/) | [Исходные коды на Github](https://github.com/ischurov/hsequantling)

<span style='font-size:80%'>Данный материал доступен под лицензией [CC BY-SA
4.0](https://creativecommons.org/licenses/by-sa/4.0/). При использовании обязательно упоминание авторов курса и аффилиации. При наличии технической возможности необходимо также указать активную гиперссылку на [страницу курса](http://hsequantling.wikispaces.com/).<span>

---

# Что обсуждалось на семинаре
## R как калькулятор
R можно использовать как калькулятор. Введите примеры, и он напишет ниже ответ.
```{r}
(4+1)*7+9-4
```
Откуда взялось и что значит `[1]`, станет ясно чуть позднее.

```{r}
57 %% 43 # Остаток от деления %%
```


```{r}
(35+7)/-Inf  # -Inf = минус бесконечность

```
Посмотрим, с какими функциями умеет работать R:
```{r}
2^2^3 # крышечка - возведение в степень
9^(0.5) # дробная тоже работает
log(100, 10) # логарифм по любому основанию (здесь основание 10)
log2(64) # логарифм по основанию два
exp(2) # экспонента
sqrt(144) # квадратный корень
sin(pi/2) # синус
cos(pi) # косинус
factorial(6) # факториал (произведение целых чисел от 1 до n)
choose(6, 2) # число сочетаний из 6 по 2 (комбинаторика)
```
Помимо одиноко стоящих чисел, R умеет и любит работат с *векторами*, то есть последовательностями чисел. Простейший пример вектора — последовательность целых чисел:
```{r}
1:6
```
Например, можно сложить кучу чисел:
```{r}
sum(1:6, 7, 10:8) # проверьте самостоятельно, что такое 10:8
```
или умножить:
```{r}
prod(1:6, 7, 10:8)
```
## Переменные
Можно создавать переменные и присваивать им значения.
```{r}
x <- 7
```
допустимо также писать `x = 7`, с некоторой разницей в обработке и хранении данных, которая сейчас не существенна. Впрочем, в большинстве случаев пишут всё-таки `<-` и некоторые руководства по стилю прямо предписывают использовать только этот синтаксис. Кстати, стрелочку можно рисовать и в другую сторону.
```{r}
8 -> y
x + y
```
Пробелы значения не имеют.
```{r}
x
x <- x + 2 # прибавить к x двойку и результат снова положить в x
x
```
Теперь `x` можно использовать при вызове различных функций
```{r}
sqrt(x)
sum(1:6, x, 10:8)
sum(1:6, 2*x, 10:8)
```

## Вектора
Мы уже сталкивались с простейшим примеров вектора — последовательностью целых чисел. В общем случае вектор создаётся с помощью функции `c`, называемой оператором *конкатенации*.

> *Конкатенация* — умное слово, которое придумали программисты, чтобы пугать ими других людей. Означает «приписывание одного к другому». И ничего более.

```{r}
a <- c(2, 1, 3) # одномерный вектор
a
```
```{r}
p <- c(2, 44:10, 3:100) # одномерный вектор
p
```
Теперь понятно, что числа в квадратных скобках в начале строк означают номер первого элемента списка в этой строке. R не различает одиночные числа и векторы из одного элемента, поэтому всегда пишет `[1]` в первой строчке (даже если там только одно число).

Напомоним, что выше мы завели вектор `a`:

```{r}
a
```

Заведём ещё один вектор:
```{r}
b <- c(5:7)
b
```
Что можно делать с векторами? Можно складывать и вычитать. Это происходит естественным образом, поэлементно:
```{r}
b-a
```
Можно умножать. Умножение происходит тоже поэлементно. С точки зрения математики это странно, но в большинстве случаев очень удобно.
```{r}
a*b
```

```{r}
a <- c(a, 4, 25) #дописать в хвост вектора
a

a <- c(3, a, 32) # дописать в начало и конец
a

sum(a) # сумма элементов вектора a
mean(a) # среднее значение элементов вектора a
median(a) # медиана
min(a) # минимум
max(a) # максимум
quantile(a, 0.25) # квантили
quantile(a, 0.75) 
quantile(a) 
```
## Как выбрать из вектора нужные элементы
Обращение к конкретным элементам вектора происходит с помощью квадратных скобок, как в Python. Нумерация начинается с 1 (не как в Python).
```{r}
a[3] # покажи третий элемент вектора
```
А вот так можно выбирать элементы вектора, удовлетворяющие некоторому условию. Заметим, что пока мы не присваиваем результат чему-нибудь, сам вектор остается неизменен.
```{r}
a
a[a<5] # все элементы меньше 5
a[a!=3] # все элементы, не равные 3
a[a==3] # все элементы, равные 3
a[c(3,5)] # покажи третий и пятый элемент
a[-c(3,4)] # покажи все, кроме третьего и четвертого элемента
a[c(-3,-4)] # то же самое
a[] # покажи все, то же что a
a[0] # тип данных, лежащих в векторе
a[10000000] # NA — not available
```
Как работает синтаксис вроде `a[a<5]`? Очень просто. Для начала посмотрим, что такое `a<5`
```{r}
a<5
```
Все операции происходят поэлементно, в том числе и операция сравнения. Она выдала нам список из булевых значений. На тех местах, на которых в исходном списке стоит элемент, удовлетворяющий условию, стоит `TRUE`, на остальных `FALSE`. Можно результат проверки записать в другую переменную.
```{r}
q <- a<5
q
```
И теперь вызвать
```{r}
a[q]
```
В этом случае выберет из вектора `a` элементы на тех местах, на которых в списке `q` стоит `TRUE`, и составит из них новый список.

> Можно писать не `TRUE` и `FALSE`, а `T` и `F`.

## Не только числа
Векторы могут содержать не только числа, но и строки. Например:
```{r}
cities = c("London", "Paris", "Madrid", "Moscow", "Tokyo")
cities[3]
colors = c("yellow", "black", "red", "grey", "green")
```
Заметим, что содержать одновременно строки и числа вектор не может:
```{r}
c(1,2,3, 12, "hello", 5)
```
Видно, что вокруг чисел появились кавычки — значит, они превратились в строчки.

## Немного картинок
```{r}
data <- c(15:5)
plot(data) # если переменная в plot одна, по оси x будет откладываться позиция элемента (Index)
plot(data, col = colors)
```
## Категориальные данные
Пусть в некотором списке содержится информация о поле респондента. Этот список может выглядеть так:

```{r}
gender <- c('male', 'female', 'male', 'male', 'female') # можно использовать как двойные так и одинарные кавычки
gender
summary(gender)
```
R полагает, что это строки, состоящие из буковок. Нам бы хотелось, чтобы он считал этот список категориальной переменной (`factor`). Для этого нужно сконвертировать его в соответствующий вид:
```{r}
gender <- as.factor(gender) #cчитай элементы значениями категории
summary(gender)
```
теперь `summary` выдаёт гораздо более осмысленные результат. Аналогичную вещь можно сделать и с данными, которые по виду числовые, но по смыслу категориальные. Например, номера групп.
```{r}
groups <- c(101, 102, 101, 102, 101, 102, 102, 103, 103, 101, 101)
groups
summary(groups) # тут summary с точки зрения чисел
groups <- as.factor(groups) # числа тоже можно сделать категориальными значениями
summary(groups) # а теперь summary с точки зрения факторов
```
Попытка вызвать, например, `median(groups)` вызовет ошибку: у категориальных данных невозможно определить медиану.

## Датафреймы
Загружаем csv:
```{r}
df <- read.csv("http://hsequantling.wikispaces.com/file/view/nanai-vowels.csv/564569635/nanai-vowels.csv", sep = ";", header = TRUE)
```
Здесь `sep` — каков разделитель ячеек (может быть, например, `";"` или  `","` или  `\t`), `header=TRUE` — если есть заголовок, `FALSE` — если нет

> NB: в R прописная/строчная буква важны, X и x — разные объекты

Две функции для работы с датафреймами:
```{r}
head(df) # покажи первые 6 строк
tail(df) # покажи последние 6 строк
```
В датафрейме `df` сейчас находятся полевые данные по нанайским гласным. Они собирались в двух деревнях Найхин и Джуен. Основным вопросом является то, разные или одинаковые форманты у гласных i и ɪ у разных информантов. Форманты — акустическая характеристика звуков, описывающая частотные диапазоны, в которых при произнесении гласного наблюдается наибольшая интенсивность. Форманты обычно нумеруют, начиная от низких частот. Считается, что большинство гласных можно описать при помощи первой и второй формант, а если по оси абсцисс отложить первую форманту (F1), а по оси ординат отложить вторую форманту (F2), то получится классическая трапеция гласных.

Описание переменных в датафрейме:

- `$dictor` — информант;
- `$sex` — пол;
- `$village` — деревня;
- `$sound` — звуки. Чтобы избежать проблем с кодировками звуки закодированы следующим образом: i = i, I = ɪ, e = ə;
- `$f1` — первая форманта;
- `$f2` — вторая форманта;

Как работать с датафреймом:

```{r}
df[2,] # покажи вторую строку датафрейма
nrow(df) # количество строк в датафрейме
ncol(df) # количество столбцов
df[nrow(df)-1, 4:ncol(df)] # номер(а) строки, номер(а) столбца
df$f1[2:5] # можно и так, но плохой тон:)

summary(df) # краткая информация по датафрейму
```

## Ещё картинки
###Гистограммы
Гистограмма — это картинка, которая строится следующим образом. На вход подаётся некоторый вектор (то есть набор чисел). Дальше отрезок между максимумом и минимумом делится на несколько частей и над каждом из получившихся отрезочков рисуется прямоугольник, высота которого равна числу точек вектора, которые лежат на этот отрезочке. Где точек больше, там и прямоугольник выше.

```{r}
hist(df$f1)
hist(df$f1, breaks = 5)
```
С помощью параметра `breaks` можно регулировать количество точек разбиения для построения гистограммы. Слишком маленькое число приведёт к меньшей информативности гистограммы, а слишком большое... тоже.

###Скаттерплоты
Скаттерплот (или точечная диаграмма, или диаграмма рассеяния) — это картинка, на которой каждой точке соответствует пара чисел: одно число это абсцисса точки, а другое число — её ордината.
```{r}
plot(-df$f2, -df$f1) # значения f2 откладываются по оси x, значения f1 по оси y
head(df[ which(df$f2 < 500 & df$f1 < 300), ] )
head(df[ (df$f2 < 500 & df$f1 < 300) , ]) # то же самое
# & — логическое И, | — логическое ИЛИ
head(df)
```
###Подписывание графиков и осей
```{r}
plot(df$f1, df$f2, main="Cюда напишем большой заголовок", 
     sub="Сюда подзаголовок",
     xlab="x-axis label", ylab="y-axis label",
     xlim=c(100, 800), ylim=c(600, 3500))
#xlim, ylim — диапазон значений на осях, с его помощью можно показать только часть скаттерплота  
plot(df$f1, df$f2, main="Нанайские гласные",
     xlab="f1", ylab="f2",
     pch=4, col="lightgray")
```
### Боксплоты (ящики с усами)

```{r}
boxplot(df$f1)
boxplot(df$f2)
par(mfrow=c(1,2)) # а теперь покажем оба сразу
boxplot(df$f1)
boxplot(df$f2)
par(mfrow=c(1,1)) # вернемся в обычный режим
```
А вот так можно нарисовать несколько боксплотов, сгруппировав данные по значению категориальной переменной:
```{r}
plot(f1 ~ sex, data=df)
```

### Полезное
Чтобы сохранить историю, можно набрать `savehistory("~/1.Rhistory")`
или просто в конце работы выделить весь код и скопировать его в текстовый файл.

Ещё одна полезная команда: `rm(list = ls(all = TRUE))` — очистить рабочую память, все переменные будут удалены.

### Ссылки

- [Конспект семинара Г. Мороза](https://www.getdatajoy.com/project/564328e07882f1fa4140abb3)
- [History семинара И. Щурова](http://pastebin.com/ieeTyxQF)
- См. также конспекты [курса 2014-15 учебного года](http://math-info.hse.ru/s14/r/) для бакалавров: [базовые возможности R](http://rpubs.com/ilyaschurov/lecture1draft) (до раздела «Теория вероятностей в R»), [работа с dataframes, гистограммы, boxplots](http://rpubs.com/ilyaschurov/lecture5). 

# Домашнее задание
## Задача 1
*(По мотивам учебника Gries.)*
Рассмотрим датафрейм, в котором представлены результаты некоторого соревнования. Указать, к каким шкалам относятся переменные, входящие в этот датафрейм.

```{r, bootstrap.show.code=F}
library(knitr)
kable(
  data.frame(
    name=c("John", "Jack", "Kevin", "Weigu"),
    reg_number=c(11,12,8,3),
    country=c("USA", "USA", "UK", "China"),
    place=c(2,3,1,4),
    time=c(10.5, 11.5, 8.3, 13.2)
    )
  )
```

## Задача 2
Создайте вектор, значения которого составляют арифметическую прогрессию от 303 до 1, за исключением тех значений, которые делятся на 4.

**Подсказка:** для вычисления остатка от деления одного числа на другое можно использовать оператор `%%`.

## Задача 3
Создайте вектор, состоящий из квадратов всех чисел от 1 до 100. Выделите из него чётные значения, не меньшие 100 и не большие 1000.

## Задача 4
Загрузите [csv с занятия](http://hsequantling.wikispaces.com/file/view/nanai-vowels.csv/564569635/nanai-vowels.csv) и найдите среднее значение и стандартное отклонение разности первой и второй формант. Постройте гистограмму и ящик с усами для этой разности.

**Подсказки:**

- Не забудьте указать правильное значение параметра `sep` при использовании `read.csv`.
- Для обращения к переменным в датафрейме нужно использовать `$`. 
- Арифметические операции с векторами всегда действуют поэлементно, то есть вектора можно складывать, вычитать, умножать и т.д.
- Гистограмма строится командой `hist`, ящик с усами командой `boxplot`.
